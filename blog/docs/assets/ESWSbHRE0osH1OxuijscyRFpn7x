
const parser = require("@babel/parser");
const generator = require("@babel/generator");
const traverse = require("@babel/traverse");
const types = require("@babel/types");
//内联对象成员值
function inlineObjectMemberValues(ast) {
  const isSimpleValue = (v) => types.isStringLiteral(v) || types.isNumericLiteral(v) || types.isBooleanLiteral(v) || types.isNullLiteral(v);
  const buildMapFromInit = (init) => {
    const m = new Map();
    if (types.isObjectExpression(init)) {
      for (const p of init.properties) {
        if (!types.isObjectProperty(p) || p.computed || !isSimpleValue(p.value)) continue;
        const k = types.isIdentifier(p.key)
          ? p.key.name
          : types.isStringLiteral(p.key)
            ? p.key.value
            : types.isNumericLiteral(p.key)
              ? String(p.key.value)
              : null;
        if (k !== null) m.set(k, p.value);
      }
    }
    return m;
  };
  traverse.default(ast, {
    VariableDeclarator(path) {
      if (!types.isIdentifier(path.node.id) || !path.node.init) return;
      const objName = path.node.id.name;
      const map = buildMapFromInit(path.node.init);
      if (map.size === 0) return;
      const binding = path.scope.getBinding(objName);
      if (!binding || binding.constantViolations.length) return;
      binding.referencePaths.forEach((rp) => {
        const p = rp.parentPath;
        if (!p || !p.isMemberExpression() || p.node.computed) return;
        if (!types.isIdentifier(p.node.object, { name: objName })) return;
        if (!types.isIdentifier(p.node.property)) return;
        const v = map.get(p.node.property.name);
        if (v) p.replaceWith(types.cloneNode(v, true));
      });
    },
  });
}

function flattenSwitchFlow(ast) { }

function removeUnusedVar(ast) {
  traverse.default(ast, {
    Program(path) {
      path.scope.crawl(); //重建一次引用
      path.traverse({
        VariableDeclarator(p) {
          if (!types.isIdentifier(p.node.id)) return;
          const binding = p.scope.getBinding(p.node.id.name);
          if (!binding || binding.constantViolations.length > 0) return;
          if (!binding.referenced) p.remove();
        },
      });
      path.stop(); //停止遍历
    },
  });
}

//字符串原始还原
function restoreStringLiteral(ast) {
  traverse.default(ast, {
    StringLiteral(path) {
      if (path.node.extra && path.node.extra.raw) {
        delete path.node.extra.raw;
      }
    },
  });
}
//内联标识符别名：var a=b; var c=a; => var c=b; 并把后续引用指向最终源头
function inlineIdentifierAliases(ast) {
  const resolve = (scope, name, seen = new Set()) => {
    if (seen.has(name)) return name;
    seen.add(name);
    const b = scope.getBinding(name);
    if (!b || b.constantViolations.length) return name;
    const p = b.path;
    let init = null;
    if (p.isVariableDeclarator()) init = p.node.init;
    if (!init || !types.isIdentifier(init)) return name;
    if (init.name === name) return name;
    return resolve(scope, init.name, seen);
  };
  traverse.default(ast, {
    Program(path) {
      path.scope.crawl();
      path.traverse({
        VariableDeclarator(p) {
          if (!types.isIdentifier(p.node.id) || !types.isIdentifier(p.node.init)) return;
          const b = p.scope.getBinding(p.node.id.name);
          if (!b || b.constantViolations.length) return;
          const target = resolve(p.scope, p.node.init.name);
          if (target !== p.node.init.name) p.node.init = types.identifier(target);
        },
        ReferencedIdentifier(p) {
          const name = p.node.name;
          const target = resolve(p.scope, name);
          if (target !== name) p.replaceWith(types.identifier(target));
        },
      });
      path.stop();
    },
  });
}
//表达式还原
function restoreExpression(ast) {
  traverse.default(ast, {
    "BinaryExpression|CallExpression|ConditionalExpression"(path) {
      try {
        const { confident, value } = path.evaluate();
        if (confident) {
          path.replaceInline(types.valueToNode(value));
        }
      } catch (e) { }
    },
  });
}

function inlineI(ast, objName = "I") {
  //get all I object properties
  const iProperties = new Map();
  const allbinds = new Set();
  traverse.default(ast, {
    VariableDeclarator(path) {
      if (types.isIdentifier(path.node.id, { name: objName })) {
        //get all properties of the I object
        const value = path.node.init;
        if (types.isObjectExpression(value)) {
          for (const p of value.properties) {
            if (types.isObjectProperty(p) && types.isStringLiteral(p.key)) {
              iProperties.set(p.key.value, p.value);
            }
          }
        }
        //get all bindings of the I object
        const binding = path.scope.getBinding(objName);
        if (binding) {
          for (const reference of binding.referencePaths) {
            const parent = reference.parent
            if (types.isMemberExpression(parent)) {
              //get parent path
              const callee = reference.parentPath.parentPath;
              if (types.isCallExpression(callee)) {
                allbinds.add(callee);
              }
            }
          }
        }
        path.stop();
      }
    },
  });
  //get all I bindings in the scope
  for (const bind of allbinds) {
    if (types.isIdentifier(bind.node.callee.object, { name: objName })) {
      console.log(bind.toString());
      const property_value = bind.node.callee.property.value;
      const arguments = bind.node.arguments;
      if (iProperties.has(property_value)) {
        const value = iProperties.get(property_value);
        if (types.isFunctionExpression(value) || types.isArrowFunctionExpression(value)) {
          const fn = value;
          const params = fn.params || [];
          if (!params.every((p) => types.isIdentifier(p))) return;
          let retExpr = null;
          if (types.isArrowFunctionExpression(fn) && !types.isBlockStatement(fn.body)) retExpr = fn.body;
          else if (types.isBlockStatement(fn.body) && fn.body.body.length === 1 && types.isReturnStatement(fn.body.body[0])) retExpr = fn.body.body[0].argument;
          if (!retExpr) return;
          if (path.node.arguments.length < params.length) return;
          const repl = new Map();
          for (let i = 0; i < params.length; i++) repl.set(params[i].name, path.node.arguments[i]);
          const out = types.cloneNode(retExpr, true);
          const wrap = types.file(types.program([types.expressionStatement(out)]));
          traverse.default(wrap, {
            Identifier(p) {
              if (!repl.has(p.node.name)) return;
              p.replaceWith(types.cloneNode(repl.get(p.node.name), true));
            },
          });
          path.replaceWith(wrap.program.body[0].expression);
        }
        else if (types.isStringLiteral(value)) {
          path.replaceWith(types.cloneNode(value, true));
        }
      }
    }

  }
}
//替换Y函数调用为DecodeY函数调用
/*
对每个 Y(数字)：
向上找最近的 TryStatement
只接受这种形态：finally 里确实有 L.pop()
在 try 块里，从开头扫到当前语句之前，取最后一次 L.push(expr) 的 expr，用 evalNum 算出 seed
用 decodeFn(index, seed) 解码并替换成字符串
*/
function replaceYCallsWithDecodeY(ast, decodeFn) {
  if (typeof decodeFn !== "function") return;
  const evalNum = (node, scope, depth = 0, seen = new Set()) => {
    if (!node || depth > 8) return null;
    if (types.isNumericLiteral(node)) {
      let n = node.value;
      const raw = node.extra && node.extra.raw;
      if (typeof raw === "string" && /^0x/i.test(raw)) {
        const p = parseInt(raw, 16);
        if (Number.isFinite(p)) n = p;
      }
      return typeof n === "number" && isFinite(n) ? n : null;
    }
    if (types.isUnaryExpression(node)) {
      const v = evalNum(node.argument, scope, depth + 1, seen);
      if (v === null) return null;
      if (node.operator === "+") return +v;
      if (node.operator === "-") return -v;
      if (node.operator === "~") return ~v;
      return null;
    }
    if (types.isBinaryExpression(node)) {
      const l = evalNum(node.left, scope, depth + 1, seen);
      const r = evalNum(node.right, scope, depth + 1, seen);
      if (l === null || r === null) return null;
      switch (node.operator) {
        case "+": return l + r;
        case "-": return l - r;
        case "*": return l * r;
        case "/": return l / r;
        case "%": return l % r;
        case "<<": return l << r;
        case ">>": return l >> r;
        case ">>>": return l >>> r;
        case "|": return l | r;
        case "&": return l & r;
        case "^": return l ^ r;
        case "**": return Math.pow(l, r);
        default: return null;
      }
    }
    if (types.isIdentifier(node)) {
      const name = node.name;
      if (seen.has(name)) return null;
      seen.add(name);
      const b = scope && scope.getBinding && scope.getBinding(name);
      if (!b || b.constantViolations.length) return null;
      if (!b.path || !b.path.isVariableDeclarator()) return null;
      return evalNum(b.path.node.init, b.path.scope, depth + 1, seen);
    }
    if (types.isCallExpression(node) && types.isIdentifier(node.callee, { name: "parseInt" })) {
      const a0 = node.arguments && node.arguments[0];
      const a1 = node.arguments && node.arguments[1];
      if (types.isStringLiteral(a0) && (!a1 || types.isNumericLiteral(a1))) {
        const radix = a1 ? a1.value : undefined;
        const v = parseInt(a0.value, radix);
        return Number.isFinite(v) ? v : null;
      }
    }
    return null;
  };
  const isLPushCall = (n) => types.isCallExpression(n) && types.isMemberExpression(n.callee) && !n.callee.computed && types.isIdentifier(n.callee.object, { name: "L" }) && types.isIdentifier(n.callee.property, { name: "push" });
  const isLPopCall = (n) => types.isCallExpression(n) && types.isMemberExpression(n.callee) && !n.callee.computed && types.isIdentifier(n.callee.object, { name: "L" }) && types.isIdentifier(n.callee.property, { name: "pop" });
  const findSeedFromNearestTry = (callPath) => {
    const stmt = callPath.getStatementParent && callPath.getStatementParent();
    if (!stmt) return null;
    let p = callPath.parentPath;
    while (p) {
      if (p.isTryStatement && p.isTryStatement()) {
        const node = p.node;
        if (!node.finalizer || !types.isBlockStatement(node.finalizer)) {
          p = p.parentPath;
          continue;
        }
        const hasPop = node.finalizer.body.some((s) => types.isExpressionStatement(s) && isLPopCall(s.expression));
        if (!hasPop) {
          p = p.parentPath;
          continue;
        }
        const body = node.block && node.block.body;
        if (!Array.isArray(body)) {
          p = p.parentPath;
          continue;
        }
        let idx = body.indexOf(stmt.node);
        if (idx < 0) idx = body.length;
        let seedExpr = null;
        for (let i = 0; i < idx; i++) {
          const s = body[i];
          if (!types.isExpressionStatement(s)) continue;
          if (!isLPushCall(s.expression)) continue;
          seedExpr = s.expression.arguments && s.expression.arguments[0];
        }
        if (!seedExpr) {
          p = p.parentPath;
          continue;
        }
        const seed = evalNum(seedExpr, stmt.scope);
        if (typeof seed === "number" && isFinite(seed)) return seed;
      }
      p = p.parentPath;
    }
    return null;
  };
  traverse.default(ast, {
    CallExpression(path) {
      const callee = path.node.callee;
      if (!types.isIdentifier(callee, { name: "Y" })) return;
      const args = path.node.arguments;
      if (!args || args.length < 1) return;
      const a0 = args[0];
      if (!types.isNumericLiteral(a0)) return;
      let n = a0.value;
      const raw = a0.extra && a0.extra.raw;
      if (typeof raw === "string" && /^0x/i.test(raw)) {
        const parsed = parseInt(raw, 16);
        if (Number.isFinite(parsed)) n = parsed;
      }
      try {
        const seed = findSeedFromNearestTry(path);
        if (typeof seed !== "number" || !isFinite(seed)) return;
        const v = decodeFn(n, seed);
        if (typeof v === "string") path.replaceWith(types.stringLiteral(v));
      } catch (e) { }
    },
  });
}

//去掉多余的逻辑代码
function removeExtraLogic(ast) {
  traverse.default(ast, {
    enter(path) {
      if (!path.isIfStatement()) return;
      const t = path.node.test;
      if (!types.isBooleanLiteral(t) && !types.isNumericLiteral(t)) return;
      const v = types.isBooleanLiteral(t) ? t.value : !!t.value;
      const pick = v ? path.node.consequent : path.node.alternate;
      if (!pick) {
        path.remove();
        return;
      }
      if (types.isBlockStatement(pick)) path.replaceWithMultiple(pick.body);
      else path.replaceWith(pick);
    },
  });
}
module.exports = {
  inlineObjectMemberValues, flattenSwitchFlow, removeUnusedVar,
  restoreStringLiteral, inlineIdentifierAliases, restoreExpression,
  replaceYCallsWithDecodeY, removeExtraLogic, inlineI
};
